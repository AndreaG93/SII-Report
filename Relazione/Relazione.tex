\documentclass[10pt,a4paper, titlepage]{report}

% Pacchetti...
% ----------------------------------------------------------------------------------------- %
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{sidecap}
\usepackage{float}
\usepackage{siunitx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{bmpsize}
\usepackage{adjustbox}
\usepackage{footnote}
\usepackage{authblk}


% Usato per personalizzare l'ambiente 'listings'...
% ----------------------------------------------------------------------------------------- %
\lstset{
language=C,
basicstyle=\small\ttfamily,			
keywordstyle=\color{blue},
commentstyle=\color{gray},			
stringstyle=\color{black},			
numbers=left,						
numberstyle=\tiny,					
stepnumber=1,						
breaklines=true						
}

% Usato per aggiugnere la numerazione alle sezioni di tipo 'subsubsection' e inserirle nell'indice...%
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

% Frontespizio...
% ----------------------------------------------------------------------------------------- %
\title{Progetto del corso di Sicurezza informatica e Internet A.A. 2017-2018}

\author[1]{Andrea Graziani (0273395)}
\author[1]{Alessandro Boccini (0277414)}
\author[1]{Ricardo Gamucci (0274716)}
\affil[1]{Università degli Studi di Roma Tor Vergata}


\date{27 marzo 2019}

% Inzio documento...
% ----------------------------------------------------------------------------------------- %
\begin{document}

\maketitle
\tableofcontents
\newpage

\chapter{Analisi tecnica del malware}

\section{Analisi dei file}

\begin{table}[h!]
  \begin{center}
    \caption{Lista dei file facentiff parte del malware FASTCash}
    \centering
    \label{tab:FilesList}
    
    \begin{adjustbox}{width=1.5\textwidth,center=\textwidth}
 
    \begin{tabular}{l|c|r}
      \toprule
      \textbf{Nome} & \textbf{SHA256} \\
      \midrule
      
      Lost\_File.so & \texttt{10ac312c8dd02e417dd24d53c99525c29d74dcbc84730351ad7a4e0a4b1a0eba} \\
      
      Unpacked\_dump\_4a740227eeb82c20... & \texttt{10ac312c8dd02e417dd24d53c99525c29d74dcbc84730351ad7a4e0a4b1a0eba} \\
  
  Lost\_File1\_so\_file & \texttt{3a5ba44f140821849de2d82d5a137c3bb5a736130dddb86b296d94e6b421594c} \\
    
      4f67f3e4a7509af1b2b1c6180a03b3... & \texttt{4a740227eeb82c20286d9c112ef95f0c1380d0e90ffb39fc75c8456db4f60756} \\ 
      
      5cfa1c2cb430bec721063e3e2d144f... & \texttt{820ca1903a30516263d630c7c08f2b95f7b65dffceb21129c51c9e21cf9551c6} \\
      
      Unpacked\_dump\_820ca1903a305162... & \texttt{9ddacbcd0700dc4b9babcd09ac1cebe23a0035099cb612e6c85ff4dffd087a26} \\
      
      8efaabb7b1700686efedadb7949eba... & \texttt{a9bc09a17d55fc790568ac864e3885434a43c33834551e027adb1896a463aafc} \\
      
      d0a8e0b685c2ea775a74389973fc92... & \texttt{ab88f12f0a30b4601dc26dbae57646efb77d5c6382fb25522c529437e5428629} \\
      
      2.so & \texttt{ca9ab48d293cc84092e8db8f0ca99cb155b30c61d32a1da7cd3687de454fe86c} \\
      
      Injection\_API\_executable\_e & \texttt{d465637518024262c063f4a82d799a4e40ff3381014972f24ea18bc23c3b27ee}\\
      
      Injection\_API\_log\_generating\_s & \texttt{e03dc5f1447f243cf1f305c58d95000ef4e7dbcc5c4e91154daa5acd83fea9a8}\\
      
      inject\_api & \texttt{f3e521996c85c0cdb2bfb3a0fd91eb03e25ba6feef2ba3a1da844f1b17278dd2}\\
      
      \bottomrule
    \end{tabular}
    \end{adjustbox}
  \end{center}
\end{table}






















\newpage
\subsection{Analisi del file \texttt{2.so}}

In base all'output ottenuto dal tool unix \texttt{file}, \texttt{2.so} è un file di tipo \textbf{eXtended COFF} (\textbf{XCOFF}) che rappresenta la versione migliorata ed estesa del formato \textbf{Common Object File Format} (\textbf{COFF}), il formato di file standard che ha definito la struttura dei file eseguibili e delle librerie nei sistemi operativi UNIX\footnote{Cfr. \texttt{https://it.wikipedia.org/wiki/COFF}} fino al 1999\footnote{Cfr. \texttt{https://en.wikipedia.org/wiki/Executable\_and\_Linkable\_Format}}, anno della definitiva adozione dello standard \textbf{Executable and Linkable Format} o \textbf{ELF}.
XCOFF rappresenta tuttavia uno standard proprietario sviluppato da IBM\footnote{Cfr. IBM - \textit{XCOFF Object File Format} - \texttt{https://www.ibm.com/support/knowledgecenter/ssw\_aix\_72/com.ibm.aix.files/XCOFF.htm} (data ultima consultazione 27-03-2019)} adottato nei sistemi operativi \textbf{Advanced Interactive eXecutive} o \textbf{AIX}, una famiglia di sistemi operativi proprietari basati su Unix sviluppati dalla stessa IBM.\footnote{Cfr. \texttt{https://www.ibm.com/it-infrastructure/power/os/aix}}

In accordo alle nostre analisi, confermate anche dal report AR18-275A della NCCIC, il file \texttt{file 2.so} rappresenta una \textbf{shared library} che esporta una serie di metodi che consentono l'iterazione con i sistemi finanziari che utilizzano il protocollo \textbf{ISO8583}.\footnote{Cfr. The National Cybersecurity and Communications Integration Center’s (NCCIC), \textit{Malware Analysis Report (AR18-275A)} - 2 Ottobre 2018 - \texttt{https://www.us-cert.gov/ncas/analysis-reports/AR18-275A)}}

\begin{table}[h!]
  \begin{center}
    \caption{Dettagli del file \texttt{2.s0}}
    \centering
    \label{tab:table1}
    
    \begin{adjustbox}{width=1.5\textwidth,center=\textwidth}
 
    \begin{tabular}{l|c|r}
      \toprule
      \textbf{Descrizione} & \textbf{Valore} & \textbf{Comando Unix} \\
      \midrule
      
      \textbf{Nome} & \texttt{2.so} & \texttt{stat -c "\%n" 2.so} \\
      
      \textbf{Dimensione (\textit{byte})} & \texttt{110592} & \texttt{stat -c "\%s" 2.so} \\
   
      \textbf{Data ultima modifca} & \texttt{2018-11-09 11:08:40.000000000 +0100} & \texttt{stat -c "\%y" 2.so} \\
   
      \textbf{Tipo di file} & \texttt{64-bit XCOFF executable or object module} & \texttt{file 2.so} \\
    
      \textbf{MD5} & \texttt{b66be2f7c046205b01453951c161e6cc} & \texttt{md5sum 2.so} \\ 
 
      \textbf{SHA1} & \texttt{ec5784548ffb33055d224c184ab2393f47566c7a} & \texttt{sha1sum 2.so} \\ 
     
      \multirow{2}{*}{\textbf{SHA256}} & \texttt{ca9ab48d293cc84092e8db8f0ca99cb1} & \multirow{2}{*}{\texttt{sha256sum 2.so}} \\ 
      & \texttt{55b30c61d32a1da7cd3687de454fe86c} & \\
      
      \multirow{2} {*}{\textbf{SHA512}} & \texttt{6890dcce36a87b4bb2d71e177f10ba27f517d1a53ab02500296f9b3aac021810} & \multirow{2}{*}{\texttt{sha512sum 2.so}} \\ 
      & \texttt{7ced483d70d757a54a5f7489106efa1c1830ef12c93a7f6f240f112c3e90efb5} & \\
      
      \bottomrule
    \end{tabular}
    \end{adjustbox}
  \end{center}
\end{table}

\subsubsection{Stringhe stampabili rilevanti}\label{strings2so}

Per estrazione di tutte le stringhe stampabili contenute nel file \texttt{2.so} ci siamo serviti del tool \texttt{strings}\footnote{Cfr. \texttt{https://linux.die.net/man/1/strings}} di cui  riportiamo frammenti dell'output ottenuto nei listati \ref{code:strings2so-1} e \ref{code:strings2so-2}.

\begin{lstlisting}[
frame=lines, 
caption={Stringe estratte dal file \texttt{2.so}}, 
label={code:strings2so-1},
firstnumber=465
]
...
_GLOBAL__FI_eg64_so
_GLOBAL__FD_eg64_so
=s4m
/opt/freeware/lib/gcc/powerpc-ibm-aix6.1.0.0/4.2.0/ppc64:/opt/freeware/lib/gcc/powerpc-ibm-aix6.1.0.0/4.2.0:/opt/freeware/lib/gcc/powerpc-ibm-aix6.1.0.0/4.2.0/../../..:/usr/lib:/lib
libc.a
shr_64.o
libpthread.a
shr_xpg5_64.o
...
\end{lstlisting}

Poiché nei sistemi operativi AIX la directory all'interno del quale sono contenute tutte le librerie di GCC assume la forma mostrata nel listato \ref{code:example-1}\footnote{http://www.perzl.org/aix/index.php\%3Fn\%3DMain.GCCBinariesVersionNeutral}, possiamo dedurre dalla riga 496 del listato \ref{code:strings2so-1} che la versione di GCC utilizzata è stata la 4.2.0 (versione rilasciata il 13 Maggio 2007\footnote{http://www.gnu.org/software/gcc/gcc-4.2/}) mentre la versione del sistema operativo bersaglio fosse stata la V6.1, versione ormai obsoleta del sistema operativo AIX il cui supporto è terminato ufficialmente il 30 Aprile del 2017.\footnote{https://www-01.ibm.com/support/docview.wss?uid=swg21634678\#AIX}
Dalla stessa riga osserviamo che l'architettura hardware del sistema bersaglio è equipaggiata con un processore PowerPC

Ovviamente il riferimento alla libreria standard \texttt{libc.c} e di GCC suggeriscono che il malware è stato scritto in C/C++.

\begin{lstlisting}[
frame=lines, 
caption={Formato del percorso di installazione delle librerie GCC nei sistemi operativi AIX}, 
label={code:example-1},
]
/opt/freeware/lib/gcc/<architecture_AIX_level>/<GCC_Level>
\end{lstlisting}

Il listato \ref{code:strings2so-2} mostra ciò che dovrebbero essere i nomi delle procedure esportate dalla libreria il che dimostra in modo inequivocabile il fatto che il malware è in grado di interagire con i sistemi informatici che fanno uso del protocollo ISO8583.

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{2.so}}, 
label={code:strings2so-2},
firstnumber=545
]
...
DL_ISO8583_MSG_Init
DL_ISO8583_MSG_Free
DL_ISO8583_MSG_SetField_Str
DL_ISO8583_MSG_SetField_Bin
DL_ISO8583_MSG_RemoveField
DL_ISO8583_MSG_HaveField
DL_ISO8583_MSG_GetField_Str
DL_ISO8583_MSG_GetField_Bin
DL_ISO8583_MSG_Pack
DL_ISO8583_MSG_Unpack
DL_ISO8583_MSG_Dump
_DL_ISO8583_MSG_AllocField
DL_ISO8583_COMMON_SetHandler
 DL_ISO8583_DEFS_1987_GetHandler
 DL_ISO8583_DEFS_1993_GetHandler
_DL_ISO8583_FIELD_Pack
_DL_ISO8583_FIELD_Unpack
...
\end{lstlisting}

\subsubsection{Analisi assembler}

Non avendo a disposizione alcuna macchina equipaggiata con un processore 



\newpage

\subsection{Analisi del file \texttt{Injection\_API\_executable\_e}}

In questa sezione dimostreremo come il file di tipo \textbf{eXtended COFF} denominato \texttt{Injection\_API\_executable\_e} sia in grado di eseguire un attacco di \textbf{code injection} a danno di un processo in esecuzione in modo tale da modificarne il comportamento a favore degli attaccanti. 

\begin{table}[h!]
  \begin{center}
    \caption{Dettagli tecnici del file \texttt{2.s0}}
    \centering
    \label{tab:table2}
    
    \begin{adjustbox}{width=1.5\textwidth,center=\textwidth}
 
    \begin{tabular}{l|c|r}
      \toprule
      \textbf{Descrizione} & \textbf{Valore} & \textbf{Comando Unix} \\
      \midrule
      
      \textbf{Nome} & \texttt{2.so} & \texttt{stat -c "\%n" 2.so} \\
      
      \textbf{Dimensione (\textit{byte})} & \texttt{89088} & \texttt{stat -c "\%s" 2.so} \\
   
      \textbf{Data ultima modifca} & \texttt{2018-11-09 11:08:40.000000000 +0100} & \texttt{stat -c "\%y" 2.so} \\
   
      \textbf{Tipo di file} & \texttt{64-bit XCOFF executable or object module} & \texttt{file 2.so} \\
    
      \textbf{MD5} & \texttt{b3efec620885e6cf5b60f72e66d908a9} & \texttt{md5sum 2.so} \\ 
 
      \textbf{SHA1} & \texttt{274b0bccb1bfc2731d86782de7babdeece379cf4} & \texttt{sha1sum 2.so} \\ 
     
      \multirow{2}{*}{\textbf{SHA256}} & \texttt{d465637518024262c063f4a82d799a4e} & \multirow{2}{*}{\texttt{sha256sum 2.so}} \\ 
      & \texttt{40ff3381014972f24ea18bc23c3b27ee} & \\
      
      \multirow{2} {*}{\textbf{SHA512}} & \texttt{a36dab1a1bc194b8acc220b23a6e36438d43fc7ac06840daa3d010fddcd9c316} & \multirow{2}{*}{\texttt{sha512sum 2.so}} \\ 
      & \texttt{8a6bf314ee13b58163967ab97a91224bfc6ba482466a9515de537d5d1fa6c5f9} & \\
      
      \bottomrule
    \end{tabular}
    \end{adjustbox}
  \end{center}
\end{table}

\subsubsection{Stringhe stampabili rilevanti}

Cominciamo lo studio del file \texttt{Injection\_API\_executable\_e} partendo dall'analisi delle stringhe stampabili estratte attraverso il tool \texttt{strings}.
Seguendo lo stesso ragionamento precedentemente descritto nella sezione \ref{strings2so}, possiamo osservare dal listato \ref{code:stringsInjectionAPIexecutablee1} la versione di GCC e del sistema operativo AIX utilizzati per eseguire la \textit{build} del malware, che risultano essere rispettivamente pari a 4.8.5 (la data pubblicazione risale al 23 giugno 2015\footnote{Cfr. https://gcc.gnu.org/gcc-4.8/}), e 7.1 (commercializzata a partire da settembre 2010).\footnote{Cfr: https://www-01.ibm.com/support/docview.wss?uid=isg3T1012517}
Sfortunatamente non è stato possibile risalire alla versione degli aggiornamenti, che IBM identifica con il nome di \textit{Technology Levels} (TLs) \footnote{http://ibmsystemsmag.com/aix/tipstechniques/migration/oslevel\_versions/}, installati sul sistema operativo bersaglio al momento dell'attacco in modo tale da conoscere l'entità del rischio a cui si sottoponeva il sistema bancario. In ogni caso il supporto ufficiale per la versione 7.1, sostituita dalla ben più moderna versione 7.2 rilasciato nel dicembre 2015, è già terminato il 30 Novembre 2013 benché la versione 7.1 TL5 riceverà supporto fino ad aprile 2022.\footnote{Cfr: https://www-01.ibm.com/support/docview.wss?uid=isg3T1012517}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee1},
firstnumber=347]
...
/opt/freeware/lib/gcc/powerpc-ibm-aix7.1.0.0/4.8.5/ppc64:/opt/freeware/lib/gcc/powerpc-ibm-aix7.1.0.0/4.8.5:/opt/freeware/lib/gcc/powerpc-ibm-aix7.1.0.0/4.8.5/../../..:/usr/lib:/lib
...
\end{lstlisting}

Un altro riferimento ai tool utilizzati dagli attaccanti lo possiamo ricavare dalla riga 944 riportata nel listato \ref{code:stringsInjectionAPIexecutablee2} dove apprendiamo l'utilizzo del compilatore lo \textbf{XL C/C++ for AIX} versione 11.1.0.1, quest'ultimo appositamente ottimizzato dalla IBM per i propri sistemi operativi. Ci risulta che tale versione del compilatore non fosse disponibile per AIX 7.1 al momento del rilascio e che sia divenuto disponibile in seguito ad un aggiornamento. \footnote{https://www-01.ibm.com/support/docview.wss?uid=swg21326972}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee2},
firstnumber=944]
...
IBM XL C for AIX, Version 11.1.0.1
...
\end{lstlisting}

Analizziamo ora in dettaglio le varie operazioni compiute dal malware durante la sua esecuzione.
Innanzitutto, osservando la particolare configurazione dei listati successivi come la numero \ref{code:stringsInjectionAPIexecutablee3}, notiamo quello che dovrebbe essere un insieme di stampe nella forma \texttt{[FUNCTION NAME] [...]} eseguito probabilmente da un meccanismo di log, il che è stato confermato dalla già citata analisi della NCCIC; infatti, notiamo un gran numero di stringhe contenenti i ben noti \textit{conversion specifier} utilizzati nelle stringhe che specificano il formato delle stampe eseguite dalla funzione \texttt{fprintf} di cui molti sono nella forma \%llX, usata per stampare numeri interi senza segno in forma esadecimale\footnote{Cfr. http://man7.org/linux/man-pages/man3/printf.3.html}. 
Come è stato confermato da altre analisi, le stringhe riportate nelle righe 333, 334 e 335 suggeriscono come l'applicazione è stata progettata per essere una command-line utility interattiva e di come il meccanismo di log sia stato utilizzato per ottenere informazioni e consentire agli attaccanti un attacco mirato.

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee3},
firstnumber=320]
...
[main] Inject Start
[main] SAVE REGISTRY
[main] proc_readmemory fail
[main] toc=%llX
[main] path::%s
[main] data(%p)::%s
[main] Exec func(%llX) OK
[main] Exec func(%llX) fail ret=%X
[main] Inject OK(%llX)
[main] Inject fail ret=%llX
[main] Eject OK
[main] Eject fail ret=%llX
Usage: injection pid dll_path mode [handle func toc]
       mode = 0 => Injection
       mode = 1 => Ejection
[main] handle=%llX, func=%llX, toc=%llX
[main] ERROR::g_pid(%X) <= 0
[main] ERROR::load_config fail
[main] ERROR::eject & argc != 7
[main] ERROR::g_dl_handle(%llX) <= 0
[main] WARNING::func_addr(%llX), toc_addr(%llX)
...
\end{lstlisting}

La presenza delle stringhe \texttt{out\_log}, \texttt{file\_dump} suggeriscono che l'output dei log venisse redirezionato verso file esterni. Forse è previsto un meccaniscmo di caricamento delle impostazioni.

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee3},
firstnumber=320]
x}8KxH
out_log
}CSx8
...
 }*J
store_config
}CSx8
...
}#Kx8?
load_config
}CSx8
...
 }*J
file_dump
@}$KxK
\end{lstlisting}


Prima di descrivere le varie fasi dell'attacco, è indispensabile comprendere come vengono rappresentati e gestiti i \textbf{processi} nei sistemi operativi AIX versione 6.1 e 7.1. 
Ogni processo del sistema viene opportunamente rappresentato da un insieme di file ognuno dei descrive un particolare aspetto di un processo come ad esempio il suo stato, le informazioni sui file descriptors, privilegi ecc.
Tutti i processi sono raccolti all'interno della directory \texttt{/proc} mentre tutti i file di un dato processo con identificatore pari a \texttt{pid} sono raccolti all'interno della directory \texttt{/proc/pid}; ciò permette agli attaccanti di
ricavare tutte le informazioni necessarie di tutto il sistema attraverso le system call standard per la lettura e scrittura sui file come \texttt{open()}, \texttt{close()}, \texttt{read()} e la \texttt{write()}. \footnote{Cfr. IBM - \textit{AIX Version 7.1: Files References} - pag. 232-246}
Di tutti i file contenuti in una generica directory \texttt{/proc/pid}, di cui ne riportiamo una piccola frazione nella tabella \ref{tab:ProcessFiles}\footnote{Per una lista completa \textit{Cfr. ivi} pag. 246}, è importante ricordare:

\begin{description}
\item[/proc/pid/as] Contiene l'immagine dello spazio degli indirizzi del processo e può essere aperto sia per la lettura che per la scrittura e supporta la subroutine lseek per accedere all'indirizzo virtuale di interesse.\footnote{\textit{Cfr. ivi} pag. 232}

\item[/proc/pid/ctl] Un file di sola scrittura in cui vengono scritti messaggi strutturati che consentono di modificare lo stato del processo e dunque il suo comportamento. I messaggi di controllo vengono scritti direttamente sul file ctl del processo e gli effetti sono visibili immediatamente attraverso i file di stato del processo.\footnote{\textit{Cfr. ivi} pag. 232}

\item[/proc/pid/status] Contiene informazioni sullo stato del processo. \footnote{\textit{Cfr. ivi} pag. 232}
\end{description}

\begin{table}[h!]
  \begin{center}
    \caption{Sottoinsieme dei file contenuti in \texttt{/proc/pid} }
    \centering
    \label{tab:ProcessFiles}
    
    \begin{tabular}{l|r}
      \toprule
      File & Descrizione \\
      \midrule
      \texttt{/proc/pid/status} & Status of process \texttt{pid} \\
      
      \texttt{/proc/pid/ctl} & Control file for process \texttt{pid} \\
      
      \texttt{/proc/pid/as} & Address space of process \texttt{pid} \\
      
      \texttt{/proc/pid/cred} & Credentials information for process \texttt{pid} \\
      
      \texttt{/proc/pid/sigact} & Signal actions for process \texttt{pid} \\
      
      \texttt{/proc/pid/sysent} & System call information for process \texttt{pid}\\
       
      \bottomrule
    \end{tabular}
  \end{center}
\end{table}

Dal momento che, come mostrato nel listato \ref{code:stringsInjectionAPIexecutablee4}, sono stati individuate tre stringhe che fanno riferimento ai suddetti file descrittori di processo, in particolare ai file \texttt{ctl}, \texttt{status} e \texttt{as}, si può affermare che il malware, ricostruendo probabilmente le directory attraverso una chiamata \texttt{sprintf} come dimostrano la presenza del \textit{conversion specifier} \texttt{\%d} e la presenza di varie stringhe \texttt{sprintf} (riga 372 e 824), è stato progettato per accedere a questi file con lo scopo di manipolare il normale flusso di esecuzione del processo bersaglio.  

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}},
label={code:stringsInjectionAPIexecutablee4},
firstnumber=320]
/proc/%d/ctl
/proc/%d/status
/proc/%d/as
\end{lstlisting}

Come abbiamo detto in precedenza, il flusso di esecuzione di un processo può essere modificato eseguendo la scrittura di appositi messaggi nel file \texttt{ctl} i quali da un codice operativo rappresentato da un int che identifica la specifica operazione seguita da ulteriori argomenti (se presenti).\footnote{\textit{Cfr. ivi} pag. 242}
Il listato \ref{code:stringsInjectionAPIexecutablee5} dimostra che il malware interrompe esplicitamente l'esecuzione del processo bersaglio attraverso l'uso del messaggio \textbf{PCWSTOP} il cui scopo è quello di arrestare l'esecuzione di un processo \texttt{pid} passato come argomento.\footnote{\textit{Ibidem}}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee5},
firstnumber=319]
...
[proc_wait] PCWSTOP pid=%d, ret=%d, err=%d(%s)
[proc_wait] tid=%d, why=%d, what=%d, flag=%d, sig=%d
...
\end{lstlisting}

Il listato \ref{code:stringsInjectionAPIexecutablee5} mostra invece l'uso di vari messaggi tra cui:
\begin{description}

\item[PCSET] Serve per impostare una serie di flag ad un processo (PR\_ASYNC, PR\_FORK, PR\_KLC ecc.).\footnote{\textit{Cfr. ivi} pag. 234} 
\item[PCRUN] Riesegue un thread dopo essere stato arrestato.
\item[PCSENTRY] Indica al thread di interrompere la sua esecuzione nel momento in cui richiama una specifica system call. 
\item[PCSFAULT] Definisce un insieme di \textit{hardware faults} tracciabili nel processo. Il thread si interrompe quando si verifica una fault.

\end{description}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee5},
firstnumber=299]
...
[proc_attach] PCSET pid=%d, ret=%d, err=%d(%s)
[proc_attach] PCSTOP pid=%d, ret=%d, err=%d(%s)
[proc_attach] PCSTRACE pid=%d, ret=%d, err=%d(%s)
[proc_attach] PCSFAULT pid=%d, ret=%d, err=%d(%s)
[proc_attach] PCSENTRY pid=%d, ret=%d, err=%d(%s)
[proc_detach] PCSTRACE pid=%d, ret=%d, err=%d(%s)
[proc_detach] PCSFAULT pid=%d, ret=%d, err=%d(%s)
[proc_detach] PCSENTRY pid=%d, ret=%d, err=%d(%s)
[proc_detach] PCRUN pid=%d, ret=%d, err=%d(%s)
...
\end{lstlisting}

I listati \ref{code:stringsInjectionAPIexecutablee6} e \ref{code:stringsInjectionAPIexecutablee7} dimostrano come il malware raccolga le informazioni necessarie al suo scopo attraverso l'accesso in lettura alle informazioni di stato del processo e al contenuto dei registri. Abbiamo riportato nella tabella \ref{tab:assembly1} una descrizione dei registri ispezionati dal malware\footnote{Cfr. IBM - \textit{AIX Version 7.1: Assembler Language Reference}}. del processore tra cui risultano

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee6},
firstnumber=299]
...
[proc_getregs] GETREG pid=%d, ret=%d, err=%d(%s)
[proc_getregs] GETSTATUS pr_syscall=%d, pr_why=%d, pr_what=%d, pr_flags=%d, pr_cursig=%d
[proc_setregs] SETREG pid=%d, ret=%d, err=%d(%s)
...
\end{lstlisting}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee7},
firstnumber=320]
[out_regs] IAR=%llX
[out_regs] MSR=%llX
[out_regs] CR=%llX
[out_regs] LR=%llX
[out_regs] CTR=%llX
[out_regs] GPR%d=%llX
\end{lstlisting}

\begin{table}[h!]
  \begin{center}
    \caption{Breve descrizione dei registri ispezionati dal malware}
    \centering
    \begin{adjustbox}{width=1.5\textwidth,center=\textwidth}
    \label{tab:assembly1}
    
    \begin{tabular}{l|l|p{8cm}}
      \toprule
      Registro & Nome esteso & Descrizione \\
      \midrule
      \texttt{LR} & Link Register & E' usato per ospitare l'indirizzo dell'istruzione successiva ad una operazione di salto. E' usata principalmente per ospitare l'indirizzo di ritorno al termine di una funzione. \\
      
      \texttt{CR} & Condition Register & Un registro da 32 bit usato per specificare varie classi di operazioni.\\
      
      \texttt{CTR} & Control Register & Un registro da 32 bit usato per specificare varie classi di operazioni.\\
      
      \texttt{IAR} & Instruction Address Register & Usato per contenere l'indirizzo dell'istruzione successiva.\\
      
      \texttt{MSR} & Machine State Register & Registro da 32 bit usato per specificare varie classi di operazioni.\\
     
	\texttt{r0-r31} & General Purpose Registers (GPRs) from 0 through 31 & Registri per usi generici. \\   
     
      \bottomrule
    \end{tabular}
    \end{adjustbox}
  \end{center}
\end{table}

https://www.ibm.com/support/knowledgecenter/en/ssw\_aix\_71/com.ibm.aix.kdb/kdb\_registers.htm


Infine nei listati \ref{code:stringsInjectionAPIexecutablee8} e \ref{code:stringsInjectionAPIexecutablee9} viene mostrato l'accesso in lettura e in scrittura allo spazio di indirizzamento del processo bersaglio e di come riavvi l'esecuzione del processo dopo la code injection.

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee9},
firstnumber=308]
...
[proc_readmemory] ret=%d, err=%d(%s), addr=%p, len=%d, data=%p
[proc_readmemory] (%X~%X) %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X
[proc_writememory] ret=%d, err=%d(%s), addr=%p, len=%d, data=%p
...
\end{lstlisting}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:stringsInjectionAPIexecutablee8},
firstnumber=308]
...
[proc_continue] PCRUN pid=%d, arg=%d, ret=%d, err=%d(%s)
...
\end{lstlisting}

PowerPC 601 RISC Microprocessor 
EA (effective address)
	
	\newpage
\subsubsection{Disassemblaggio}
	
	\begin{table}[h!]
	  \begin{center}
	    \caption{Alcune istruzioni assembly disponibili nell'architettura PowerPC\texttrademark}
	    \centering
	    
	    \label{tab:AssemblyIstrucions}
	    \begin{adjustbox}{center=\textwidth}
	    \begin{tabular}{l|l|l|p{6cm}}
	      \toprule
	      Istruzione & Nome & Argomenti & Descrizione \\
	   		\midrule
	   		\texttt{bl} & \textit{Branch Link} & \texttt{\textit{target\_address}} & \textit{Branches to a specified target address.} \\
	   	
   	       \texttt{mfcr} & \textit{Move From Condition Register} & \texttt{RT} & \textit{Copies the contents of the Condition Register into a general-purpose register.} \\
 
	       \texttt{std} & \textit{STore Doubleword} & \texttt{RS,\textit{Offset},RSML} & \textit{Store a doubleword of data from a general purpose register into a specified memory location.}\\
	       
	       \texttt{stw} & \textit{STore Word} & \texttt{RS,\textit{Offset},RSML} & \textit{Stores a word of data from a general-purpose register into a specified location in memory.} \\
	       
	       \texttt{li} & \textit{Load Immediate} & \texttt{RT,\textit{Value}} & \textit{Copies specified value into a general-purpose register.} \\
	       
	       \texttt{ld} & \textit{Load Doubleword} & \texttt{RT,\textit{Offset},RS} & \textit{Load a doubleword of data into the specified general purpose register.} \\
	       
	       \texttt{mr} & \textit{Move Register} & \texttt{RT,RS} & \textit{Copies the contents of one register into another register.} \\
	       
	       \texttt{addi} & \textit{ADD Immediate} & \texttt{RT,RS,\textit{Value}} & \textit{Place the sum of the contents of RA and the 16-bit two's complement integer value, sign-extended to 32 bits, into the target RT.} \\
	       	
	       	\texttt{mtrl} & \textit{Move To Link Register} & \texttt{RS} & \textit{Copies the contents of RS register into Link Register.} \\

\texttt{extsw} & \textit{Extend Sign Word} & \texttt{RT,RS} & \textit{Copy the low-order 32 bits of a general purpose register into another general purpose register, and signextend the fullword to a doubleword in size (64 bits).} \\
	       	
	      \bottomrule
	    \end{tabular}
	       \end{adjustbox}
	  \end{center}
	\end{table}

\paragraph{Analisi della procedura \texttt{main}} 

La parte iniziale della procedura \texttt{main} è caratterizzata da una serie di operazioni che coinvolgono stringhe come dimostrano la serie di istruzioni di salto condizionato verso le funzioni \texttt{strlen} (riga 7028), \texttt{strncpy} (riga 7035) e \texttt{strtoull} (riga 6973, 6984 e 6995) che probabilmente sono state utilizzate per raccogliere informazioni. Sono presenti due istruzioni di salto vero le funzioni \texttt{atoi} (riga 7015 e 7041) usate per convertire i parametri passati dagli attaccanti attraverso la linea di comando il che dimostra la natura interattiva del malware.

Dopo una serie di istruzioni di salto verso procedure varie procedure di inizilizzazione, tra cui spiccano \texttt{load\_config} e \texttt{get\_func\_addr}, viene raggiunta la porzione di codice mostrata nel listato \ref{code:AssemblyFunction-main-1} dove, dopo aver copiato i dati necessari in alcuni registri attraverso le apposite istruzioni mr, vengono eseguite a cascata due istruzioni di salto verso una procedura chiamata inject, che contiene il codice operativo per l'esecuzione della code injection. 

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:AssemblyFunction-main-1},
firstnumber=308]
mr      r3,r10
mr      r4,r9
addi    r5,r2,-728
bl      0x1000256c <.inject>
li      r3,120
bl      0x10003468 <.sleep>
ld      r2,40(r1)
addi    r10,r31,120
lwz     r9,116(r31)
extsw   r9,r9
mr      r3,r10
mr      r4,r9
li      r5,0
bl      0x1000256c <.inject>
bl      0x10001154 <.CloseHandle>
\end{lstlisting}



\paragraph{Analisi della procedura \texttt{inject}}

In questo paragrafo descriveremo le operazioni eseguite dalla procedura chiamata \texttt{inject} a cui gli autori del malware hanno affidato il compito di eseguire l'attacco di code injection a danno del processo bersaglio.
Nel listato \ref{code:AssemblyFunction-inject-01} viene mostrato il frammento corrispondente alla prima parte della suddetta funzione, all'interno del quale possiamo distinguere le seguenti operazioni:
\begin{itemize}
\item Copia nel \textit{link register} dell'indirizzo di ritorno dal registro \texttt{r0} attraverso l'istruzione \texttt{mflr}.
\item Inizializzazione di vari registri necessari attraverso varie istruzioni \texttt{std} e \texttt{mr} che coinvolgono i registri \texttt{r4}, \texttt{r5},\texttt{r9} e  \texttt{r31}, quest'ultimo probabilmente adibito ad ospitare l'indirizzo di memoria di base da cui viene computato l'indirizzo da cui prelevare i dati dalla memoria. Si presupponi che i registri precedentemente menzionati ospiteranno gli indirizzi alle celle di memoria contenenti il codice malevolo che verrà poi scritto all'interno dello spazio di indirizzamento del processo bersaglio.
\item Esecuzione della code injection vera e propria attraverso una serie di istruzioni di salto (\texttt{bl}) verso l'indirizzo \texttt{0x10002f00} corrispondente alla prima istruzione della funzione \texttt{memset} preceduta dalle necessarie inizializzazioni dei registri di input attraverso varie istruzioni \texttt{mr}.
\end{itemize}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:AssemblyFunction-inject-01},
firstnumber=308]
mflr    r0
std     r0,16(r1)
std     r31,-8(r1)
stdu    r1,-1520(r1)
mr      r31,r1
std     r3,1568(r31)
mr      r9,r4
std     r5,1584(r31)
stw     r9,1576(r31)
li      r9,0
stw     r9,120(r31)
li      r9,0
std     r9,144(r31)
addi    r10,r31,152
li      r9,384
mr      r3,r10
li      r4,0
mr      r5,r9
bl      0x10002f00 <.memset>
nop
addi    r10,r31,536
li      r9,384
mr      r3,r10
li      r4,0
mr      r5,r9
bl      0x10002f00 <.memset>
nop
addi    r10,r31,920
li      r9,256
mr      r3,r10
li      r4,0
mr      r5,r9
bl      0x10002f00 <.memset>
\end{lstlisting}

Dopo una serie di istruzioni di salto verso la funzione \texttt{memset}, ed aver dunque conclusa le operazioni di modifica della memoria del processo attaccato, possiamo osservare le successive operazioni eseguite dal listato \ref{code:AssemblyFunction-inject-02} in cui apprendiamo che:

\begin{itemize}
\item Vengono eseguite ben tre istruzioni \texttt{bl} per permettere l'esecuzione della procedura \texttt{out\_log} per effettuare la scrittura delle informazioni di interesse su un file esterno.
\item Vengono diverse istruzioni di salto per eseguire varie procedure tra cui quella denominata \texttt{proc\_attach}, usata probabilmente per modificare alcune informazioni di stato del processo, la \texttt{proc\_wait}, usata probabilmente per arrestare l'esecuzione del processo bersaglio, \texttt{proc\_getregs} ed \texttt{out\_regs} usate rispettivamente per leggere i valori contenuti nei registri e successivamente scriverli in un file di log.

\end{itemize}

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:AssemblyFunction-inject-02},
firstnumber=308]
bl      0x10000674 <.out_log>
bl      0x10001220 <.proc_attach>
li      r3,0
bl      0x10001a28 <.proc_continue>
li      r3,0
li      r4,0
bl      0x10001b44 <.proc_wait>
ld      r3,728(r2)
bl      0x10000674 <.out_log>
addi    r9,r31,152
mr      r3,r9
bl      0x10001ee4 <.proc_getregs>
addi    r9,r31,152
mr      r3,r9
bl      0x10000c80 <.out_regs>
\end{lstlisting}

Dopo una serie di istruzioni di salto verso altre funzioni, tra cui figura una denominata \texttt{proc\_readmemory}, avviene l'ultima fase della code injection durante la quale, come dimostrato dal listato \ref{code:AssemblyFunction-inject-03}, viene alterata la memoria del processo bersaglio attraverso istruzioni di salto verso le procedure \texttt{proc\_writememory}, usata probabilmente per indurre il processo bersaglio a eseguire il codice malevolo copiato in precedenza, e la \texttt{proc\_setregs} usata per alterare il contenuto dei registri e dunque modificare il futuro comportamento del processo. La procedura si conclude con il riavvio del processo e una lunga fase di log attraverso una grande quantità di istruzioni di salto verso la procedura \texttt{out\_log}.

\begin{lstlisting}[
frame=lines, 
caption={Stringhe estratte dal file \texttt{Injection\_API\_executable\_e}}, 
label={code:AssemblyFunction-inject-03},
firstnumber=308]
bl      0x10002460 <.proc_writememory>
addi    r9,r31,536
mr      r3,r9
bl      0x10000c80 <.out_regs>
addi    r9,r31,536
mr      r3,r9
bl      0x10002068 <.proc_setregs>
li      r3,3
bl      0x10001a28 <.proc_continue>
li      r3,6
li      r4,11
bl      0x10001b44 <.proc_wait>
addi    r9,r31,536
mr      r3,r9
bl      0x10001ee4 <.proc_getregs>
addi    r9,r31,536
mr      r3,r9
bl      0x10000c80 <.out_regs>
\end{lstlisting}

\paragraph{Analisi della procedura \texttt{proc\_attach}}

Analizziamo nel dettaglio l'attacco al processo la quale si compone in varie fare.
Nel listato possiamo osservare come vengono dapprima eseguite delle operazioni di store ward con diversi offset con un registro comune come indirizzo sorgente; 

Successivamente gli attaccanti utilizzano quello che probabilmente si tratti dell'indirizzo dell'area di memoria del processo bersaglio e con ripetute operazioni si store word muove il puntatore a quell'area di memoria con step da 4 byte. Alla fine, raggiunta la posizione desiderata, sposta il risultato in vari registri e esegue un'operazione di salto (bl) che punta all'indirizzo per la funzione memset.

\begin{lstlisting}
<.proc_attach>:
mflr    r0
std     r0,16(r1)
std     r29,-24(r1)
std     r30,-16(r1)
std     r31,-8(r1)
stdu    r1,-352(r1)
mr      r31,r1
li      r9,0
stw     r9,128(r31)
li      r9,0
stw     r9,132(r31)
li      r9,0
std     r9,136(r31)
li      r9,0
std     r9,144(r31)
li      r9,0
std     r9,152(r31)
li      r9,0
std     r9,160(r31)
li      r9,0
std     r9,168(r31)
li      r9,0
stw     r9,176(r31)
addi    r10,r31,180
li      r9,140
mr      r3,r10
li      r4,0
mr      r5,r9
bl      0x10002f00 <.memset>
\end{lstlisting}

Dopo aver richiamato la funzione \texttt{memset}, certamente utilizzata dagli attaccanti per eseguire la \textit{code injection} alterando il contenuto dello spazio di indirizzamento del processo bersaglio, la funzione \texttt{proc\_attach} incomincia una fase di logging durante la quale, attraverso ripetuti salti condizionati agli indirizzi \texttt{0x100031ec}, \texttt{0x1000319c} e \texttt{0x10000674}, corrispondenti agli indirizzi delle funzioni \texttt{write}, \texttt{sterror} (utilizzata certamente dagli attaccanti per verificare l'output della funzione \texttt{write}), \texttt{log\_out}, vengono archiviati in un file esterno il contenuto dei registri di interesse che paiono essere i registri r31, r30, r29 e r9 che vengono copiati con ripetute istruzioni \texttt{mr} in registri ausiliari (r4, r5, r6 e r7 rispettivamente) prima di essere inviati come input alla funzione \texttt{log\_out}.

\begin{lstlisting}
li      r9,14
stw     r9,136(r31)
li      r9,4
stw     r9,140(r31)
addi    r9,r2,-764
lwz     r9,0(r9)
extsw   r10,r9
addi    r9,r31,136
mr      r3,r10
mr      r4,r9
li      r5,8
bl      0x100031ec <.write>
ld      r2,40(r1)
mr      r9,r3
stw     r9,128(r31)
addi    r9,r2,-768
lwz     r9,0(r9)
extsw   r29,r9
ld      r9,128(r2)
lwz     r9,0(r9)
extsw   r30,r9
ld      r9,128(r2)
lwz     r9,0(r9)
extsw   r9,r9
mr      r3,r9
bl      0x1000319c <.strerror>
ld      r2,40(r1)
mr      r9,r3
lwz     r10,128(r31)
extsw   r10,r10
ld      r3,536(r2)
mr      r4,r29
mr      r5,r10
mr      r6,r30
mr      r7,r9
bl      0x10000674 <.out_log>
\end{lstlisting}

La fase di code injection si conclude con il caricamento nel registro \texttt{r0} dell'indirizzo della funzione chiamante copiato successivamente nel link register attraverso l'istruzione \texttt{mtrl}; vengono in seguito eseguite una serie di istruzioni ld per popolare i registri r29, r30 e r31 che conterranno probabilmente i valori di ritorno della funzione per poi eseguire una istruzione \texttt{blr} (\textit{Branch Link Register}).

\begin{lstlisting}
ld      r0,16(r1)
mtlr    r0
ld      r29,-24(r1)
ld      r30,-16(r1)
ld      r31,-8(r1)
blr
\end{lstlisting}


\begin{lstlisting}
bl      0x10000674 <.out_log>
bl      0x10001220 <.proc_attach>
li      r3,0
bl      0x10001a28 <.proc_continue>
li      r3,0
li      r4,0
bl      0x10001b44 <.proc_wait>
ld      r3,728(r2)
bl      0x10000674 <.out_log>
addi    r9,r31,152
mr      r3,r9
bl      0x10001ee4 <.proc_getregs>
addi    r9,r31,152
mr      r3,r9
bl      0x10000c80 <.out_regs>
addi    r8,r31,536
addi    r10,r31,152
li      r9,384
mr      r3,r8
mr      r4,r10
mr      r5,r9
bl      0x1000324c <.memmove>
nop
ld      r9,536(r31)
addi    r9,r9,-16
mr      r3,r9
li      r4,16384
bl      0x10000b48 <.file_dump>
\end{lstlisting}






La traduzione dal linguaggio macchina all'assembler del file è stato usufrendo del servizio web https://onlinedisassembler.com/ per motivi di semplicità con le seguenti impostazioni

architettura powerpc620
processore POWER 7
64 bit

Queste impostazioni ci hanno permesso di ottenere un output sostanzialmente identico a quello mostrato in vari screenshot dalla CISA




ftp://public.dhe.ibm.com/systems/power/docs/aix/72/idalangref\_pdf.pdf



    
 	Specifies a 24-bit signed two's-complement integer that is concatenated on the right with 0b00 and sign-extended to 64 bits (PowerPC®) or 32 bits (POWER® family). This is an immediate field.

 	https://www.ibm.com/support/knowledgecenter/ssw\_aix\_72/com.ibm.aix.alangref/idalangref\_inst\_fields.htm
 	
 	mflr r0 \# move LR into GPR0
 	
 	 If a branch instruction has the Link bit set to 1, then the Link Register is altered to store thereturn address for use by an invoked subroutine. The return address is the address of the instructionimmediately following the branch instruction (pag 33)


The following code transfers the execution of the program to here and sets the Link Register: 

https://www.ibm.com/support/knowledgecenter/en/ssw\_aix\_71/com.ibm.aix.alangref/idalangref\_bbranchinst.htm


\listoffigures
\listoftables
\lstlistoflistings

\end{document}













